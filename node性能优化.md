如何找到Node.js性能优化杀手
阅读这篇文章Node.js性能优化杀手，你应该能够：
检测JavaScript引擎是否优化了函数（V8）
检测优化函数是否优化
检测为什么函数无法优化

在V8中，代码被动态优化; 这意味着代码根据其运行时行为进行优化。
该过程在运行时发生。V8分析代码的行为，开发启发式算法，并根据观察到的结果进行优化。

例如，V8侦察函数的输入和输出，以查看它是否可以执行类型断言。如果一个函数的参数的类型总是相同的，从这个断言来优化这个函数似乎是安全的。

V8执行多种优化的情况，但基于参数类型的一个可能是最容易描述的。


node index.js
通常，要运行此文件，我们将使用命令$ node index.js。要跟踪优化，我们将在命令行中添加一个参数。

node --trace-opt index.js | grep myFunc//我的电脑跑这个和网站上的不一样(你自己试试)
该函数被标记为重新编译。这是优化函数的第一步。
然后该函数被重新编译和优化。
...随后是去优化

重点
现在去运行index2.js
node --trace-deopt --trace-opt index2.js | grep myFunc

这个日志的第一部分非常类似于前面的段落。
然而，存在其中函数被去优化的第二部分：V8检测到之前做出的类型假设（“myFunc的输入是数字”）是假的。
之前的算法:错误的启发式
在这个简短的例子中，我们看到了如何跟踪函数的优化和非优化。我们也看到了V8的启发式是如何脆弱的。它引导我们第一个声明：

即使JavaScript不是强类型，V8也有优化规则。因此，将连贯的类型作为函数的参数和返回值是一个好主意。
***********************************
之前都是优化的 现在是非优化
非优化
在前面的例子中，我们看到在被优化之前，一个函数被标记为重新编译。
有时，V8会将函数标记为不可优化。让我们运行以下代码：
node --trace-deopt --trace-opt try.js | grep myFunc

所以这一次，而不是标记为优化，myFunc已标记为“不可优化”。原因在日志中提供：“TryCatchStatement”。

按设计，包含a的函数try - catch语句被视为不可优化。

这里的逻辑很简单;在JavaScript中有在运行时可以有非常不同的行为的模式。V8决定永远不优化这些功能，以避免落入去优化的地狱。

重点:
由于v8的特性
去优化地狱
当函数在运行时被优化和非优化时，在V8中发生去优化地狱。
经过几个周期的优化/去优化，V8会将该方法标记为不可优化。然而，在该周期中将损失大量的时间，对过程性能和存储器消耗造成影响。
有很多其他模式阻止V8的优化。他们列在aGithub存储库。
阻止v8优化的网址
https://github.com/vhf/v8-bailout-reasons

围绕非优化
我们现在将看到一个不那么优雅的方法来处理非优化模式，通过try-catch语句的例子。让我们运行：
node --trace-opt tryHack.js
在此日志中，它似乎：

tryThis的优化已禁用，因为它包含try-catch语句
myFunc已优化
tryThis被标记为重新编译，但它从不发生，因为它被禁用此功能
这导致我们另一个V8优化的原则：
隔离不优化的单独函数中的非优化模式。

结论
在本文中，我们了解了如何跟踪Node.js中的优化，非优化和非优化。这是您通过优化Node.js代码的良好开端。
http://mrale.ph/irhydra/2/
命名了一个探索优化和去优化的高级工具IRHydra。有关Node.js的用法的简短介绍可以在上找到Eugene Obrezkov的博客。
https://blog.ghaiklor.com/tracing-de-optimizations-in-nodejs-2ba16900fc6f#.ci4hihd68


